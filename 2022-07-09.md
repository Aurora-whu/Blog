# 数组模拟邻接表

`#define maxn 105`

`struct edge{`

`    int v;`

`    int next;`

`}e[maxn];`

`int eid,p[maxn];`      <mark> //头指针p</mark>

`void init()`                <mark> //初始化</mark>

`{`

`    eid=0;`

`    memset(p,-1,sizeof(p));`

`}`

`void insert(int x,int y)`       <mark>//头插法（单向）</mark>

`{`

`    e[eid].v=y;`

`    e[eid].next=p[x];`

`    p[x]=eid++;`

`}`

`void insert2(int x,int y)`        <mark>//双向</mark>

`{`

`    insert(x,y);`

`    insert(y,x);`

`}`

# 快速排序

`int partition(int arr[], int low, int high){`

`    int key;`

`    key = arr[low];`

`    while(low<high){`

`        while(low <high && arr[high]>= key )`

`            high--;`

`        if(low<high)`

`            {`

`                arr[low] = arr[high];`

`                low++;`

`            }`

`        while( low<high && arr[low]<=key )`

`            low++;`

`        if(low<high)`

`            {`

`                arr[high] = arr[low];`

`                high--;`

`            }`

`    }`

`    arr[low] = key;`

`    return low;`

`}`

`void quick_sort(int arr[], int start, int end){`

`    int pos;`

`    if (start<end){`

`        pos = partition(arr, start, end);`

`        quick_sort(arr,start,pos-1);`

`        quick_sort(arr,pos+1,end);`

`    }`

`    return;`

`}`



# 纸牌均分问题

##### 题意：有n堆纸牌，每一堆有纸牌若干张，总数为n的倍数，且纸牌只能与相邻堆的纸牌移动，且第一堆只能与第二堆互相移动，最后一堆只能与前一堆移动，试问至少移动多少次能使各堆纸牌数量相等。

（贪心）算法分析：**1**、从左往右开始看，从第一堆分析，若第一堆多了，则向右移动多出的牌数。

                                   **2**、若第一少了，则从第二堆移动缺少的牌数。

                                   **3**、但是会出现一个问题，若后面一堆的牌数少于前面需要的牌数。那么可以先搁置，意味着后面的牌数必然有多，可以先从左往右移动，若第一次出现前i张纸牌的数量大于或者等于i*平均数时，从第i堆纸牌开始向前移动，每次移动的牌数为前面缺少的牌数。这样前面的牌数就可以被补齐。

                                    **4**、综上分析，每两堆纸牌最多只需要移动一次，且移动的牌数为多出或缺少的必要的纸牌数量。（也可以用分块的思想）明白思想后，代码就非常简单，但是思考过程还是非常复杂的。



# KMP字符串匹配

```
void Getnext(int next[],String t)
{
   int j=0,k=-1;
   next[0]=-1;
   while(j<t.length-1)
   {
      if(k == -1 || t[j] == t[k])
      {
         j++;k++;
         next[j] = k;
      }
      else k = next[k];//此语句是这段代码最反人类的地方，如果你一下子就能看懂，那么请允许我称呼你一声大神！
   }
}

```

```
int KMP(String s,String t)
{
   int next[MaxSize],i=0;j=0;
   Getnext(t,next);
   while(i<s.length&&j<t.length)
   {
      if(j==-1 || s[i]==t[j])
      {
         i++;
         j++;
      }
      else j=next[j];               //j回退。。。
   }
   if(j>=t.length)
       return (i-t.length);         //匹配成功，返回子串的位置
   else
      return (-1);           
       //没找到
}
```

```
void Getnext(int next[],String t)        //改进后的next函数
{
   int j=0,k=-1;
   next[0]=-1;
   while(j<t.length-1)
   {
      if(k == -1 || t[j] == t[k])
      {
         j++;k++;
         if(t[j]==t[k])//当两个字符相同时，就跳过
            next[j] = next[k];
         else
            next[j] = k;
      }
      else k = next[k];
   }
}


```
